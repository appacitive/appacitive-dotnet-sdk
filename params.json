{"name":"Appacitive-dotnet-sdk","tagline":"Appacitive .NET SDK","body":"\r\n.NET SDK for appacitive\r\n=====================\r\n\r\nThis open source library allows you to integrate applications built using Microsoft .NET or Mono with the Appacitive platform.\r\nTo learn more about the Appacitive platform, please visit [www.appacitive.com][1].\r\n\r\nLICENSE\r\n\r\nExcept as otherwise noted, the .NET SDK for Appacitive is licensed under the [Apache License, Version 2.0][2].\r\n\r\n# Documentation \r\n\r\n## Setup\r\n\r\nThe appacitive .NET SDK can be added to your project via [nuget](https://www.nuget.org/packages/Appacitive).\r\nSimply run the following command\r\n\r\n> ## PM> **Install-Package Appacitive**\r\n\r\non the nuget package manager console to include the appacitive .NET SDK in your project. \r\n\r\n## Initialize\r\n\r\nBefore we dive into using the SDK, we need to understand a couple of things about using the Appacitive api.\r\n\r\nAll calls to the appacitive platform are secured using an app specific api key.\r\nTo access the api key for your app, go to app listing via the [portal](https://portal.appacitive.com) and click on the key icon on right side. \r\n\r\n![\"Getting your apikey\"](http:\\/\\/appacitive.github.io\\/images\\/portal-apikey-small.png)\r\n\r\n####Initialize your SDK, \r\n\r\n```c#\r\nApp.Initialize(\r\n    platform,       // Use the Platforms helper class for options. \r\n    appid,          // Set your application id here.\r\n    apiKey,         // Set your api key here.\r\n    env,            // Set your environment here. Use Environment enum. \r\n    settings);      // App settings (optional). \r\n\r\n```\r\n#### What is this platform variable?\r\nYou can use the .NET sdk as part of your mobile app as well as any server side application like ASP.net or WCF. These enviroments vary quite significantly \r\nin terms of how certain operations are performed e.g., network calls.\r\n\r\nThe `platform` input parameter is provided to hint the SDK into the runtime environment in which it is hosted. For example, using `Platforms.Aspnet` essentially tells the sdk that it is being hosted inside a web application. Based on this, the SDK can pick the right mechanism for features like user auth and session management.\r\n\r\nDepending upon the type of project that you are using, the Platforms helper class may present one or more of the following options - `Platforms.WindowsPhone7`, `Platforms.WindowsPhone8`, `Platforms.Aspnet`, `Platforms.Wcf` or `Platforms.Nonweb`\r\n\r\nNow you are ready to use the SDK\r\n\r\n## Conventions\r\n1. The .NET SDK makes extensive use of .NET Tasks along with async \\ await feature recently introduced with c# 5.0. As a result, most methods exposed via the SDK are async methods.\r\n\r\n2. The SDK follows a certain naming convention for the various appacitive data types.\r\n - The SDK defines the following primary data types - `APObject`, `APConnection`, `APUser` and `APDevice`.\r\n - For each primary data type, there is a corresponding helper type with a plural name - `APObjects`, `APConnections`, `APUsers` and `APDevices`.\r\n - Write operations are performed on instances of a specific type.\r\n - Read, Delete and Find operations are performed via static operations on the corresponding helper type.\r\n    ```c#\r\n    // To read an object\r\n    // Notice the plural APObject(s) below.\r\n    var obj = await APObjects.GetAsync(\"object\", \"123\");\r\n    \r\n    // To create or update\r\n    await obj.SaveAsync();\r\n    ```\r\n3. Incase an api call fails, an exception extending from `BaseAppacitiveException` would be raised.\r\n\r\n## Debugging the SDK\r\n\r\nDebugging in the sdk uses standard .NET trace infrastructure via the App.Debug class. To setup debugging for your app\r\n\r\n#### Setup .NET tracing\r\nAdd the following configuration to your app.config or web.config. Add a trace listener of your choice. The given configuration will log everything to the console.\r\n\r\n```xml\r\n    <system.diagnostics>\r\n        <trace autoflush=\"true\" indentsize=\"4\">\r\n            <listeners>\r\n                <clear />\r\n                <add name=\"configConsoleListener\" type=\"System.Diagnostics.ConsoleTraceListener\" />\r\n            </listeners>\r\n            </trace>\r\n    </system.diagnostics>\r\n```\r\n\r\n#### Setup SDK debugging\r\n\r\nThe code below shows how to enable debugging for standard scenarios.\r\n\r\n``` C#\r\n\t// To enable logging of all transactions.\r\n\tApp.Debug.ApiLogging.LogEverything();\r\n\r\n\t// To log only failed calls.\r\n\tApp.Debug.ApiLogging.LogFailures();\r\n\t\r\n\t// To log calls taking more than 600ms.\r\n\tApp.Debug.ApiLogging.LogSlowCalls(600);\r\n\r\n\t// To log calls based on runtime condition.\r\n\tApp.Debug.ApiLogging.LogIf((rq, rs) => rs.Status.Code == \"400\");\r\n\r\n\t// To log failed and slow calls.\r\n\tApp.Debug.ApiLogging\r\n\t\t\t .LogFailures()\r\n\t\t\t .LogSlowCalls(600);\r\n\r\n```\r\n----------\r\n\r\n\r\n## Data storage and retrieval\r\n\r\nAll data is represented as objects. This will become clearer as you read on. Let's assume that we are building a game and we need to store player data on the server.\r\n\r\n### Creating\r\nTo create a player via the sdk, do the following\r\n```c#\r\nvar player = new APObject(\"player\");\r\n```\r\nHuh?\r\n\r\nAn `APObject` comprises of an entity (referred to as `object` in Appacitive jargon). To initialize an object, we need to provide it some options. The mandatory argument is the `__type` argument.\r\n\r\nWhat is a type? In short, think of types as tables in a contemporary relational database. A type has properties which hold values just like columns in a table. A property has a data type and additional constraints are configured according to your application's need. Thus we are specifying that the player is supposed to contain an entity of the type 'player' (which should already be defined in your application).\r\n\r\nThe player object is an instance of `APObject`. An `APObject` is a class which encapsulates the data (the actual entity or the object) and methods that provide ways to update it, delete it etc. To see the raw entity that is stored within the `APObject`, fire `player.ToJSON()`.\r\n\r\n#### Setting Values\r\nNow we need to name our player 'John Doe'. This can be done as follows\r\n```csharp\r\n // Using setters\r\n var player = new APObject(\"player\");\r\n player.Set(\"name\", \"John Doe\");\r\n \r\n // dynamically assigning properties (via the use of the dynamic keyword)\r\n dynamic player = new APObject(\"player\");\r\n player.name = \"John Doe\";\r\n```\r\n#### Getting values\r\nLets verify that our player is indeed called 'John Doe'\r\n```csharp\r\n// using the getters\r\nvar name = player.Get<String>(\"name\");\r\n\r\n// Using the getter with a default value\r\n// This will return N.A. incase the name property is not available.\r\nvar name = playet.Get<string>(\"name\", \"N.A.\");\r\n\r\n// dynamic usage\r\n// Assuming that player is declared via the dynamic keyword.\r\n// player.Name, player.NAme etc would also work here.\r\nvar name = player.name;\r\n```\r\n\r\n#### Saving\r\nSaving a player to the server is easy.\r\n```csharp\r\nvar player = new APObject(\"player\");\r\nplayer.Set(\"name\", \"John Doe\");\r\nplayer.Set(\"age\", 22);\r\nawait player.SaveAsync();\r\nConsole.WriteLine(\"New player created with id {0}.\", player.Id);\r\n```\r\nWhen you call save, the object is taken and stored on Appacitive's servers. A unique object id is generated and is stored along with the player object. This identifier is also returned to the object on the client-side. You can access it directly using `Id` property. This is available in the `player` object after a successful save.\r\n\r\n### Retrieving\r\n\r\nYou can retrieving an existing object instance from the backend via its type and unique id.\r\n\r\n```csharp\r\n// retrieve the player\r\nvar id = \"12345\";\r\nvar player = await APObjects.GetAsync(\"player\", id);\r\n```\r\n\r\nIf you want to update an object and need a reference to it without making a call to the server, you can create a new instance by passing the type and id in the constructor. This instance is a loose reference to the object on the server side without actually making a call to the backend.\r\n\r\n```csharp\r\n// Retrieve the player\r\n// The existingPlayer object represents the player object with id 12345.\r\nvar existingPlayerId = \"12345\";\r\nvar existingPlayer = new APObject(\"player\", existingPlayerId);\r\n\r\n```\r\n\r\n**Note**:  You can mention exactly which all fields you want returned so as to reduce the overall payload size. By default all fields are returned. Fields `Id` and `Type` are the fields which will always be returned. \r\n\r\n```csharp\r\n// You can choose to get specific fields only by passing the fields needed.\r\n// The following sample will get only the name and age fields.\r\nvar player = await APObjects.GetAsync(\"player\", \"12345\", new[] { \"name\", \"age\" });\r\n```\r\nYou can also retrieve multiple objects at a time, which will return an array of `APObject` instances. Here's an example\r\n\r\n```csharp\r\nvar ids = new [] {\"14696753262625025\", \"14696753262625026\", \"14696753262625027\"};\r\nvar fields = new[] { \"name\", \"age\" };       // optional fields to get\r\nvar players = await APObjects.MultiGetAsync(\"player\", ids, fields);\r\n\r\n\r\n```\r\n### Updating\r\n\r\nYou can update an existing object via the SaveAsync() instance method on `APObject`.\r\nSaving an object will update the instance with the latest values from the server.\r\n\r\n```csharp\r\n// Get existing player\r\nvar player = await APObjects.GetAsync(\"player\", \"12345\");\r\n// Update name and age\r\nplayer.Set(\"name\", \"Jack\");\r\nplayer.Set(\"age\", 24);\r\n// Save\r\nawait player.SaveAsync();\r\n\r\n```\r\nAs you might notice, updates and creates are both done via the `SaveAsync` method. The SDK combines the create operation and the update operation under the hood and provides a unified interface. This is done be detecting the presence of a non-zero `Id` property. \r\nThis also means that the `Id` property on all APObjects or derived types are immutable.\r\n\r\n#### Handling concurrent updates\r\n\r\nIt is possible that multiple clients may be updating the same object instance on the backend. To prevent any accidental bad writes, Appacitive provides a revision number based [Multi Version Concurrency Control (MVCC)][3] mechanism.\r\n\r\nEach object instance has a integer based Revision property which is internally incremented on each update. If you want to ensure that you are always updating the correct object, you can pass the current revision number of the object during the update. If this revision number matches the revision on the server, the update will be allowed. In case the revision number does not match, it implies that the object has changed since you last read it. Accordingly the update operation will be cancelled.\r\n\r\n```csharp\r\n// Get existing player (say at revision # 3 on the server)\r\nvar player = await APObjects.GetAsync(\"player\", \"12345\");\r\n// Update name and age\r\nplayer.Set(\"name\", \"Jack\");\r\nplayer.Set(\"age\", 24);\r\n\r\n// Save (this call will succeed)\r\nvar revision = player.Revision;     // revision = 3     \r\nawait player.SaveAsync(revision);\r\n\r\n// Save again with old revision (this call will fail as revision number is now 4)\r\nawait player.SaveAsync(revision);\r\n```\r\n\r\n### Deleting\r\n\r\nYou can delete an APObject via the `DeleteAsync` method on the `APObjects` helper class. Let's say we've had enough of John Doe and delete his player account from the server. Here's how you can do that -\r\n\r\n```csharp\r\n// This will delete player with id 12345.\r\nawait APObjects.DeleteAsync(\"player\", \"12345\");\r\n```\r\n\r\nYou can also delete object along with all its first degree [connections](#connections).\r\nNote that this will only delete the connections and not the connected objects.\r\n```csharp\r\nvar deleteConnections = true;\r\nawait APObjects.DeleteAsync(\"player\", \"12345\", deleteConnections);\r\n```\r\nMultiple objects can also be deleted at a time. The delete connections options is not available for multi deletes. Here's an example\r\n```csharp\r\nvar ids = var ids = new [] {\"14696753262625025\", \"14696753262625026\"};\r\nawait APObjects.MultiDeleteAsync(\"player\", ids);\r\n```                                                        \r\n\r\n----------\r\n\r\n## Connections\r\n\r\nAll data that resides in the Appacitive platform is relational, like in the real world. This means you can do operations like fetching all games that any particular player has played, adding a new player to a team or disbanding a team whilst still keeping the other teams and their `players` data perfectly intact.\r\n\r\nTwo entities can be connected via a relation, for example two entites of type `person` might be connected via a relation `friend` or `enemy` and so on. An entity of type `person` might be connected to an entity of type `house` via a relation `owns`. \r\n\r\nOne more thing to understand is the concept of labels. Consider an entity of type `person`. This entity is connected to another `person` via relation `marriage`. Within the context of the relation `marriage`, one person is the `husband` and the other is the `wife`. Similarly the same entity can be connected to an entity of type `house` via the relation `house_owner`. In context of this relation, the entity of type `person` can be referred to as the `owner`. \r\n\r\n`Wife`, `husband` and `owner` from the previous example are `labels`. Labels are used within the scope of a relation to give contextual meaning to the entities involved in that relation. They have no meaning or impact outside of the relation.\r\n\r\nLet's jump in!\r\n\r\n\r\n### Creating &amp; Saving\r\n\r\nThe SDK provides a very fluent interface for creating connections.\r\nYou can mix and match various options, to create a connection for your specific application scenario. \r\n\r\n#### New Connection between two existing Objects\r\n\r\nBefore we go about creating connections, we need two entities. Consider the following\r\n\r\n```csharp\r\nvar idForJohn = \"12345\";\r\nvar idForJane =  \"39209\";\r\n// initialize and set up a connection\r\n// This will setup a connection of type sibling between the objects\r\n// with the given ids.\r\nvar conn = await APConnection\r\n                .New(\"marriage\")\r\n                .FromExistingObject(\"husband\", idForJohn)\r\n                .ToExistingObject(\"wife\", idForJane)\r\n                .SaveAsync();\r\n\r\n```\r\n\r\nIf you've read the previous guide, most of this should be familiar. What happens in the `APConnection` class is that the relation is configured to actually connect the two entities. We provide the ids of the two entities to be connected and specify which is which. For example here, John is the husband and Jane is the wife. \r\n\r\nIn case you are wondering why this is necessary then here is the answer, it allows you to structure queries like 'who is John's wife?' and much more. Queries are covered in later guides.\r\n\r\n`conn` is an instance of `APConnection` of type `marriage`. Similar to an entity, you may call `ToJSON` on a connection to get a json representation of the connection.\r\n\r\n#### New Connection between two new Objects\r\n\r\nApart from connecting existing objects, you can also create and connect new objects in one go. For example, say I want to create an order and its invoice in one go.\r\n\r\n```csharp\r\n// Create new objects for order and invoice\r\nvar order = new APObject(\"order\");\r\norder.Set(\"order_number\", 747383);\r\nvar invoice = new APObject(\"invoice\");\r\ninvoice.Set(\"invoice_date\", DateTime.Now);\r\n\r\n// Create both objects and connect them with a connection of type invoices\r\nawait APConnection.New(\"invoices\")\r\n            .FromNewObject(\"order\", order)\r\n            .ToNewObject(\"invoice\", invoice)\r\n            .SaveAsync();\r\nConsole.WriteLine(\"Order id: {0}\", order.Id);\r\nConsole.WriteLine(\"Invoice id: {0}\", invoice.Id);\r\n```\r\n\r\nThis is the recommended way to do it. In this case, the invoices relation will create the objects order and invoice first and then connect them using the relation `invoices`.\r\n\r\nAs you can probably guess from the examples above, you can change `FromNewObject` to `FromExistingObject` and `ToNewObject` to `ToExistingObject`, depending on whether you are connecting an new object or an existing one.\r\n\r\n#### Connection properties\r\nLike in the case of objects, connections can have user defined properties and attributes as well. For example, a relation of type `employed` between a `user` and a `company` can contain a property called `joining_date`. This makes sense since the joining date is not a property of the user or the company in isolation. \r\n\r\nProperties in connections work exactly in the same way as they work in objects.\r\n\r\n```csharp\r\n// This works exactly the same as in case of your standard objects.\r\n// Setting property values\r\nAPConnection employed;\r\nemployed.Set(\"joining_date\", DateTime.Now);\r\n\r\n// Reading property values\r\nvar joiningDate = employed.Get<DateTime>(\"joining_date\");\r\n```\r\n### Retrieving\r\n\r\n#### Get Connection by Id\r\n\r\n```csharp\r\nvar conn = await APConnections.GetAsync(\"employed\", \"123456\");\r\n```\r\nThe `APConnection` object is similar to the `APObject`, except you get one new field viz. `Endpoints`. Endpoints represent the two objects that the connection links.\r\n\r\n```csharp\r\nvar idForJohn = \"12345\";\r\nvar idForJane =  \"39209\";\r\nvar conn = await APConnection\r\n                .New(\"marriage\")\r\n                .FromExistingObject(\"husband\", idForJohn)\r\n                .ToExistingObject(\"wife\", idForJane)\r\n                .SaveAsync();\r\n                \r\nvar john = await conn.Endpoints[\"husband\"].GetObjectAsync();\r\nvar jane = await conn.Endpoints[\"wife\"].GetObjectAsync();\r\n```\r\n\r\n#### Get Connected Objects\r\n\r\nConsider you want to get a list of all people who are friends of John. Essentially what you want is all objects of type `person` who are connected to John via the relation 'friend'. \r\n\r\n```csharp\r\nvar john = new APObject(\"person\", \"12345\");\r\n// Returns a paged list of friends. \r\n// We are assuming that the labels for the friend relationship is the same for both endpoints as a friend relationship is not directed.\r\nvar friends = await john.GetConnectedObjectsAsync(\"friend\", pageSize:200);\r\n// Write all names to console.\r\nfriends.ForEach( f => Console.WriteLine( f.Get<string>(\"name\"));\r\n// Get next page.\r\nvar nextPage = await friends.NextPageAsync();\r\n```\r\n\r\nNOTE: Incase the relation you are querying is between the same type with different labels, then you must provide the label of the object that you are querying. Example, consider the relationship `father` between `person` objects. In this relationship, the same object can participate as the `father` as well as the `child` with different objects. When querying the `father` connection for John, you will need to specify the label as `father` to get a list of all John's children.\r\n\r\nIn all other scenarios, passing a label is optional.\r\n\r\n#### Get all Connections for an Endpoint Object Id\r\n\r\nScenarios where you may need to just get all connections of a particular relation for an objectId, this query comes to rescue.\r\n\r\nConsider `Jane` is connected to some objects of type `person` via `invite` relationship, that also contains a `bool` property viz. `attending`,  which is false by default and will be set to true if that person is attending marriage.\r\n\r\nNow she wants to know who all are attending her marriage without actually fetching their connected `person` object, this can be done as\r\n\r\n```javascript\r\n//set an instance of person Object for Jane \r\nvar jane = new Appacitive.Object({ __id : '123345456', __type : 'person');\r\n\r\n//call fetchConnectedObjects with all options that're supported by queries syntax\r\n// we'll cover queries in dept in next section\r\nvar query = jane.getConnections({\r\n  relation: 'invite', //mandatory\r\n  label: 'invitee', //mandatory\r\n  filter: Appacitive.Filter.Property('attending').equalTo(true)\r\n});\r\n\r\nquery.fetch().then(function(invites) {\r\n  //invites is an array of connections\r\n  console.log(invites);\r\n});\r\n```\r\n\r\nIn this query, you provide a relation type (name) and a label of opposite side whose conenction you want to fetch and what is returned is a list of all the connections for above object. \r\n\r\n#### Get Connection by Endpoint Object Ids\r\n\r\nAppacitive also provides a reverse way to fetch a connection  between two objects.\r\nIf you provide two object ids of same or different type types, all connections between those two objects are returned.\r\n\r\nConsider you want to check whether `Tarzan` and `Jane` are married, you can do it as\r\n```javascript\r\n//'marriage' is the relation between person type\r\n//and 'husband' and 'wife' are the endpoint labels\r\nvar query = Appacitive.Connection.getBetweenObjectsForRelation({ \r\n    relation: \"marriage\", //mandatory\r\n    objectAId : \"22322\", //mandatory \r\n    objectBId : \"33422\", //mandatory\r\n    label : \"wife\" //madatory for a relation between same type and differenct labels\r\n});\r\n\r\nquery.fetch().then(function(marriage){\r\n  if(marriage != null) {\r\n      // connection obj is returned as argument to onsuccess\r\n      alert('Tarzan and jane are married at location ', marriage.get('location'));\r\n    } else {\r\n      alert('Tarzan and jane are not married');\r\n    }\r\n});\r\n\r\n//For a relation between same type type and differenct endpoint labels\r\n//'label' parameter becomes mandatory for the get call\r\n\r\n```\r\n\r\nConside you want to check that a particular `house` is owned by `Jane`, you can do it by fetching connection for relation `owns_house` between `person` and `house`.\r\n```javascript\r\nvar query = Appacitive.Connection.getBetweenObjectsForRelation({ \r\n    relation: \"owns_house\", \r\n    objectAId : \"22322\", // person type entity id\r\n    objectBId : \"33422\" //house type entity id\r\n});\r\n\r\nquery.fetch().then(function(obj) {\r\n    if(obj != null) {\r\n      alert('Jane owns this house');\r\n    } else {\r\n      alert(\"Jane doesn't owns this house\");\r\n    }\r\n});\r\n```\r\n\r\n#### Get all connections between two Object Ids\r\n\r\nConsider `jane` is connected to `tarzan` via a `marriage` and a `freind` relationship. If we want to fetch al connections between them we could do this as\r\n\r\n```javascript\r\nvar query = Appacitive.Connection.getBetweenObjects({\r\n  objectAId : \"22322\", // id of jane\r\n    objectBId : \"33422\" // id of tarzan\r\n});\r\n\r\nquery.fetch().then(function(connections) {\r\n  console.log(connections);\r\n});\r\n```\r\nOn success, we get a list of all connections that connects `jane` and `tarzan`.\r\n\r\n#### Get Interconnections between one and multiple Object Ids\r\n\r\nConsider, `jane` wants to what type of connections exists between her and a group of persons and houses , she could do this as\r\n```javascript\r\nvar query = Appacitive.Connection.getInterconnects({\r\n  objectAId: '13432',\r\n    objectBIds: ['32423423', '2342342', '63453425', '345345342']\r\n});\r\n\r\nquery.fetch().then(function(connections) {\r\n  console.log(connections);\r\n}, function(err) {\r\n  alert(\"code:\" + err.code + \"\\nmessage:\" + err.message);\r\n});\r\n```\r\n\r\nThis would return all connections with object id 13432 on one side and '32423423', '2342342', '63453425' or '345345342' on the other side, if they exist.\r\n\r\n### Updating\r\n\r\n\r\nUpdating is done exactly in the same way as entities, i.e. via the `save()` method. \r\n\r\n*Important*: Updating the endpoints (the `__endpointa` and the `__endpointb` property) will not have any effect and will fail the call. In case you need to change the connected entities, you need to delete the connection and create a new one. \r\n```javascript\r\nmarriage.set('location', 'Las Vegas');\r\n\r\nmarriage.save().then(function(obj) {\r\n    alert('saved successfully!');\r\n});\r\n```\r\nAs before, do not modify the `__id` property.\r\n\r\n \r\n### Deleting\r\n\r\nDeleting is provided via the `del` method.\r\n```javascript\r\nmarriage.destroy().then(function() {\r\n  alert('Tarzan and Jane are no longer married.');\r\n});\r\n\r\n\r\n// Multiple coonection can also be deleted at a time. Here's an example\r\nAppacitive.Object.multiDelete({   \r\n  relation: 'freinds', //name of relation\r\n  ids: [\"14696753262625025\", \"14696753262625026\", \"14696753262625027\"], //array of connection ids to delete\r\n}).then(function() { \r\n  //successfully deleted all connections\r\n});\r\n```\r\n\r\n----------\r\n\r\n## Queries\r\n\r\nQueries provide a mechanism to search your application data.\r\nAll searching in SDK is done via `Appacitive.Sdk.Query` object. You can retrieve many objects at once, put conditions on the objects you wish to retrieve, and much more.\r\n\r\nThe following basic uqery apis are available inside the SDK. Queries apart from these can be made using the Graph api feature discussed later.\r\n\r\n#### Query api\r\n\r\n```csharp\r\n/// Find all objects of a given type with the given filters.\r\nTask<PagedList<APObject>> FindAllAsync(\r\n    string type,                                // type to query\r\n    IQuery query = null,                        // query filter\r\n    IEnumerable<string> fields = null,          // fields to retrieve\r\n    int page = 1,                               // page number\r\n    int pageSize = 20,                          // page size\r\n    string orderBy = null,                      // sort field\r\n    SortOrder sortOrder = SortOrder.Descending  // sort order\r\n    )\r\n\r\n/// Find all objects connected to the given object with the given filters.\r\nTask<PagedList<APObject>> GetConnectedObjectsAsync(\r\nstring relation,                                // relation to query\r\n    string query = null,                        // query filter\r\n    string label = null,                        // label of the object \r\n    IEnumerable<string> fields = null,          // fields to retrieve\r\n    int pageNumber = 1,                         // page number\r\n    int pageSize = 20,                          // page size\r\n    string orderBy = null,                      // sort field\r\n    SortOrder sortOrder = SortOrder.Descending) // sort order\r\n```\r\n\r\nAs an example, to find all people with first name as John, we would do the following.\r\n\r\n```csharp\r\nList<APObject> allMatches = new List<APObject>();\r\nvar query = Query.Property(\"firstname\").IsEqualTo(\"john\");\r\n// Run query. Returns a paged response with pagesize 200.\r\nvar matches = await APObjects.FindAllAsync(\"person\", query, pageSize: 200);\r\nallMatches.AddRange(matches);\r\n// Incase more records are present, paginate\r\nwhile( !matches.IsLastPage )\r\n{\r\n    matches = await matches.GetNextPageAsync();\r\n    allMatches.AddRange(matches);\r\n}\r\n```\r\n\r\n### Modifiers\r\n\r\nNotice the `page`, `pageNumber`, `orderBy`, `sortOrder`, `query`, and `fields`? These're the optional parameters that you can specify in a query. Lets get to them one by one.\r\n\r\n#### Pagination\r\n\r\nAll queries on the Appacitive platform support pagination and sorting. To specify pagination and sorting on your queries, simply pass the `page`, `pagesize`. The resulting object also contains custom properties like `IsLastPage` as well as methods like `GetNextPageAsync()` to help you get to the next page without having to pass all your parameters again.\r\n\r\n#### Sorting\r\nQuery results can be sorted using the `orderBy` and `sortOrder` parameters.\r\nThe `orderBy` parameter takes the name of the property on which to sort and the `sortOrder` parameter lets you select the order of sorting (ascending or descending).\r\n\r\n#### Fields\r\n\r\nAs in the case of single and multi get apis, you can choose the exact set of fields that you want the api to return. Pass in an array of the properties to be returned in the `fields` parameter to apply this modifier to the query results.\r\n\r\n#### Filters\r\n\r\nFilters are useful for fine tuning the results of your search. Objects and connections inside Appacitive have 4 different types of data, namely - properties, attributes, aggregates and tags. Filters can be applied on each and every one of these. Combinations of these filters is also possible.\r\n\r\nThe `Query` object provides a factory for creating filters for appacitive without having to learn the specialized query format used by the underlying REST api.\r\nThe typical format for the Query helper class is \r\n```csharp\r\nQuery.{Property|Attribute|Aggregate}(\"name\").<Condition>(condition args);\r\n```\r\nSome sample examples of how it can be used are \r\n```csharp \r\n// To query on a property called firstname\r\nvar query = Query.Property(\"firstname\").IsEqualTo(\"John\");\r\n\r\n// To query on an attribute called nickname\r\nvar query = Query.Attribute(\"nickname\").IsEqualTo(\"John\");\r\n\r\n// To query on an aggregate called avg_rating\r\nvar query = Query.Aggregate(\"avg_rating\").IsGreaterThan(4.5);\r\n```\r\nIn response it returns you an `IQuery` object, which encapsulates the specified filter in object form. \r\n\r\n\r\n#### List of supported conditions\r\n\r\n| Condition | Sample usage |\r\n| ------------- |:-----| \r\n| **Geography properties** |\r\n| WithinPolygon() | ``` Query.Property(\"location\").WithinPolygon(geocodes); ```\r\n| WithinCircle() | ```Query.Property(\"location\").WithinCircle(geocode, radius); ```|\r\n| **String properties** |\r\n| StartsWith() | ```Query.Property(\"name\").StartsWith(\"Ja\"); ```|\r\n| Like()| ```Query.Property(\"name\").Like(\"an\"); ```|\r\n| FreeTextMatches()**   | ```Query.Property(\"description\").FreeTextMatches(\"roam~0.8\"); ```|\r\n| EndsWith() | ```Query.Property(\"name\").EndsWith(\"ne\"); ``` |\r\n| IsEqualTo() | ```Query.Property(\"name\").IsEqualTo(\"Jane\"); ``` |\r\n| **Text properties** |\r\n| FreeTextMatches()**   |```Query.Property(\"description\").FreeTextMatches(\"roam~0.8\"); ```|\r\n| **Time properties ** |\r\n| BetweenTime() | ```Query.Property(\"start_time\").BetweenTime(startDate, endDate);``` |\r\n| IsEqualToTime() | ```Query.Property(\"start_time\").IsEqualToTime(DateTime.Now);``` |\r\n| IsLessThanTime() | ```Query.Property(\"start_time\").IsLessThanTime(DateTime.Now);``` |\r\n| IsLessThanEqualToTime() | ```Query.Property(\"start_time\").IsLessThanEqualToTime(DateTime.Now);``` |\r\n| IsGreaterThanTime()| ```Query.Property(\"start_time\").IsGreaterThanTime(DateTime.Now);``` |\r\n| IsGreaterThanEqualToTime()| ```Query.Property(\"start_time\").IsGreaterThanEqualToTime(DateTime.Now);``` |\r\n| **Date properties ** |\r\n| BetweenDate() | ```Query.Property(\"start_at\").BetweenDate(startDateTime, endDateTime);``` |\r\n| IsEqualToDate()| ```Query.Property(\"start_at\").IsEqualToDate(DateTime.Now);``` |\r\n| IsLessThanDate() | ```Query.Property(\"start_at\").IsLessThanDate(DateTime.Now);``` | ```Query.Property(\"start_at\").IsLessThanDate(DateTime.Now);``` |\r\n| IsLessThanEqualToDate() | ```Query.Property(\"start_at\").IsLessThanEqualToDate(DateTime.Now);``` |\r\n| IsGreaterThanDate() | ```Query.Property(\"start_at\").IsGreaterThanDate(DateTime.Now);``` |\r\n| IsGreaterThanEqualToDate() | ```Query.Property(\"start_at\").IsGreaterThanEqualToDate(DateTime.Now);``` |\r\n| **Datetime, int and decimal properties** ||\r\n| IsLessThan() | ```Query.Property(\"field\").IsLessThan(value);``` |\r\n| IsLessThanEqualTo() | ```Query.Property(\"field\").IsLessThanEqualTo(value);``` |\r\n| Between() | ```Query.Property(\"field\").Between(start, end);``` |\r\n| IsGreaterThanEqualTo() | ```Query.Property(\"field\").IsGreaterThanEqualTo(value);``` |\r\n| IsGreaterThan() | ```Query.Property(\"field\").IsGreaterThan(value);``` |\r\n| IsEqualTo() | ```Query.Property(\"field\").IsEqualTo(value);``` |\r\n** Supports [Lucene query parser syntax][4] \r\n\r\n#### Geolocation\r\n\r\nYou can specify a property type as a geography type for a given type or relation. These properties are essential latitude-longitude pairs. Such properties support geo queries based on a user defined radial or polygonal region on the map. These are extremely useful for making map based or location based searches. E.g., searching for a list of all restaurants within 20 miles of a given users locations.\r\n\r\n##### Radial Search\r\n\r\nA radial search allows you to search for all records of a specific type which contain a geocode which lies within a predefined distance from a point on the map. A radial search requires the following parameters.\r\n\r\n```csharp\r\n//create a new Geocode object\r\nvar center = new Geocode(36.1749687195m, -115.1372222900m);\r\n//create filter\r\nvar query = Query.Property(\"location\").WithinCircle(center, 20.0m, DistanceUnit.Miles);\r\n//create query object\r\nvar restaurants = await APObjects.FindAllAsync(\"restaurant\", query);\r\n```\r\n\r\n##### Polygon Search\r\n\r\nA polygon search is a more generic form of geographcal search. It allows you to specify a polygonal region on the map via a set of geocodes indicating the vertices of the polygon. The search will allow you to query for all data of a specific type that lies within the given polygon. This is typically useful when you want finer grained control on the shape of the region to search.\r\n\r\n```csharp\r\n//create geocode objects\r\nvar pt1 = new Geocode(36.1749687195m, -115.1372222900m);\r\nvar pt2 = new Geocode(34.1749687195m, -116.1372222900m);\r\nvar pt3 = new Geocode(35.1749687195m, -114.1372222900m);\r\nvar pt4 = new Geocode(36.1749687195m, -114.1372222900m);\r\n\r\n//create polygon filter\r\nvar query = Query.Property(\"location\").WithinPolygon(pt1, pt2, pt3, pt4);\r\n\r\n//create query object\r\nvar restaurants = await APObjects.FindAllAsync(\"restaurant\", query);\r\n```\r\n\r\n#### Tag Based Searches\r\n\r\nThe Appacitive platform provides inbuilt support for tagging on all data (objects, connections, users and devices). You can use this tag information to query for a specific data set. The different options available for searching based on tags is detailed in the sections below.\r\n\r\n##### Query data tagged with one or more of the given tags\r\n\r\nFor data of a given type, you can query for all records that are tagged with one or more tags from a given list. For example - querying for all objects of type message that are tagged as personal or private.\r\n\r\n```csharp\r\n// Create the query\r\nvar query = Query.Tags.MatchOneOrMore(\"personal\", \"private\");\r\n// Will return messages tagged with either personal or private or both.\r\nvar messages = await APObjects.FindAllAsync(\"message\", query);\r\n```\r\n\r\n##### Query data tagged with all of the given tags\r\n\r\nAn alternative variation of the above tag based search allows you to query for all records that are tagged with all the tags from a given list. For example, querying for all objects of type message that are tagged as personal AND private.\r\n\r\n```csharp\r\n// Create the query \r\nvar query = Query.Tags.MatchAll(\"personal\", \"private\");\r\n// Will return messages tagged with both personal and private.\r\nvar messages = await APObjects.FindAllAsync(\"message\", query);\r\n```\r\n\r\n#### Compound Queries\r\n\r\nCompound queries allow you to combine multiple queries into one single query. The multiple queries can be combined using `Query.And` and `Query.Or` operators. \r\n`NOTE`: All types of queries with the exception of free text queries can be combined into a compound query.\r\n\r\n```csharp\r\n/* \r\nFind all users\r\n- whose first name is John or Jane and \r\n- who stay within 20 mile radius of the empire state building.\r\n*/\r\nvar locationOfEmpireState = new Geocode(40.7484m, 73.9857m);\r\nvar query = Query.And(\r\n                Query.Or(\r\n                    Query.Property(\"firstname\").IsEqualTo(\"john\"),\r\n                    Query.Property(\"firstname\").IsEqualTo(\"jane\")\r\n                    ),\r\n                Query.Property(\"location\").WithinCircle(locationOfEmpireState, 20.0m, DistanceUnit.Miles)\r\n                );\r\n\r\nvar matches = await APObjects.FindAllAsync(\"person\", query);\r\n```\r\n\r\n#### FreeText\r\n\r\nThere are situations when you would want the ability to search across all text content inside your data. Free text queries are ideal for implementing this kind of functionality. As an example, consider a free text lookup for users which searches across the username, firstname, lastname, profile description etc. \r\n\r\n`NOTE`: Free text queries support the [Lucene query parser syntax][4]  for free text search. \r\n\r\n```csharp\r\nvar places = await APObjects.FreeTextSearchAsync(\"places\", \"+champs +palais\", pageSize:200);\r\n```\r\n\r\n----------\r\n\r\n## Graph Search\r\n\r\nAppacitive graph queries offer immense potential when it comes to filtering and retreiving connected data. There are two kinds of graph operations, graph queries and graph apis.\r\n\r\n### Creating graph queries\r\n\r\nYou can create graph queries and graph apis from the management portal. When you create such queries from the portal, you are required to assign a unique name with every saved search query. You can then use this name to execute the query from your app by making the appropriate api call to Appacitive.\r\n\r\n### Executing saved graph queries\r\n\r\nYou can execute a saved graph api (query or api) by using its name that you assigned to it while creating it from the management portal. You will need to send any placeholders you might have set up while creating the query as a list of key-value pairs in the body of the request. \r\n\r\n```csharp\r\n\r\n// Name of graph query\r\nvar graphQueryName = \"find_connected_users\";  \r\n// any placeholders if provided : optional\r\nvar placeHolders = new Dictionary<string, string>\r\n                    {\r\n                        {\"key1\", \"value1\"},\r\n                        {\"key2\", \"value2\"}\r\n                    };\r\nvar matchingIDs = await Graph.Query(graphQueryName, placeHolders);\r\n```\r\n\r\n### Executing saved graph api\r\n\r\nExecuting saved graph apis works the same way as executing saved graph queries. The only difference is that you also need to pass the initial ids as an array of strings to feed the api. The response to a graph api will depend on how you design your graph api. Do test them out using the query builder from the query tab on the management portal and from the test harness.\r\n\r\n```csharp\r\n\r\n// Name of graph projection query\r\nvar graphApiName = \"get_my_profile\";\r\n// List of ids for which to run the graph api\r\nvar userIds = [\"34912447775245454\", \"34322447235528474\", \"34943243891025029\"];\r\n// any placeholders if provided : optional\r\nvar placeHolders = new Dictionary<string, string>\r\n                    {\r\n                        {\"key1\", \"value1\"},\r\n                        {\"key2\", \"value2\"}\r\n                    };\r\nGraphNode[] results = await Graph.Select(graphApiName, userIds, placeHolders);\r\n```\r\n-----------\r\n\r\n## User Management\r\n\r\nUsers represent your app's users. There is a host of different functions/features available in the SDK to make managing users easier. The `APUser` and `APUsers` types deals with user management.\r\n\r\n### Create\r\n\r\nThere are multiple ways to create users.\r\n\r\n#### Basic\r\n\r\nYou create users the same way you create any other data.\r\n```csharp\r\n// set the fields\r\nvar user = new APUser();\r\nuser.Username = \"john.doe\";\r\nuser.Password = \"p@ssw0rd\";\r\nuser.Email = \"john.doe@appacitive.com\";\r\nuser.FirstName = \"John\";\r\nuser.LastName = \"Doe\";\r\n// Save the user.\r\nawait user.SaveAsync();\r\n```\r\n\r\n### Retrieve\r\n\r\nThere are three ways you could retreive the user\r\n\r\n#### By id.\r\nFetching users by `Id` is exactly like fetching objects and connections. Let's say you want to fetch user with `Id` 12345.\r\n```csharp\r\nvar user = await APUsers.GetByIdAsync(\"12345\");\r\n```\r\n**Note**: The APUser class is a subclass of APObject. As a result, all operations supported by `APObject`, can be performed on `APUser` object. So, above data documenation is valid for users too.\r\n\r\n#### By username\r\n\r\n```csharp\r\n//fetch user by username\r\nvar user = await APUsers.GetByUsernameAsync(\"john.doe\");\r\n```\r\n### Update\r\nThere's no difference between updating a user and updating an APObject. Updates can be applied to the backend via the `SaveAsync` method.\r\n\r\n```csharp\r\nvar user = await APUsers.GetByIdAsync(\"12345\");\r\nuser.Set(\"email\", \"john.doe2@appacitive.com\");\r\nawait user.SaveAsync();\r\n```\r\n\r\n### Delete\r\nYou can delete an existing user via the `DeleteUserAsync` method on the APUsers helper class.\r\n\r\n```csharp\r\nvar userId = \"12345\";\r\nawait APUsers.DeleteUserAsync(userId);\r\n```\r\n\r\n### Authentication\r\n\r\nAuthentication is the core of user management. You can authenticate (log in) users in multiple ways. Once the user has authenticated successfully, you will be provided the user's details and an access token. This access token identifies the currently logged in user session. \r\nYou can also initialize the app with this token. This will send this token with every api call. This way the api can infer that the given call is made in the context of the logged in user. Access control rules may also dictate the need to send this token.\r\n\r\n```csharp\r\n// To initialize the app with an existing token.\r\nvar token = \"1lqsljkasldjalsu1....\";\r\nawait App.LoginAsync(new UserTokenCredentials(token));\r\n\r\n// To authenticate and initialize the app with the logged in user.\r\nvar usernamePassword = new UsernamePasswordCredentials(username, password);\r\nawait App.LoginAsync(usernamePassword);\r\n```\r\n\r\n#### Login via username + password\r\n\r\nYou can ask your users to authenticate via their username and password.\r\n```csharp\r\n// To simply authenticate the username and password\r\nvar credentials = new UsernamePasswordCredentials(username, password);\r\nvar userSession = await credentials.AuthenticateAsync();\r\nConsole.WriteLine(\"Logged in user: {0}\", userSession.LoggedInUser.Username);\r\nConsole.WriteLine(\"User token: {0}\", userSession.UserToken);\r\n```\r\nYou can also authenticate the user and set the user as the logged in user for the app in one go.\r\n\r\n```csharp\r\nvar usernamePassword = new UsernamePasswordCredentials(username, password);\r\nawait App.LoginAsync(usernamePassword);\r\n```\r\n\r\n#### Login with Facebook\r\n\r\nYou can ask your users to log in via facebook. To do this, you will need to implement the facebook oauth handshake in your app to get the user access token.\r\nYou can use the facebook sdk specific to your platform for this purpose.\r\nOnce you have the access token, simply create a new instance of an `OAuth2Credentials` object to authenticate.\r\n\r\n```csharp\r\nvar authType = \"facebook\";\r\nvar facebookAccessToken = \"laksjalsjd... \"; // Facebook access token from oauth handshake\r\nvar facebookCredentials = new OAuth2Credentials(\r\n    facebookAccessToken, \r\n    authType);\r\nfacebookCredentials.CreateUserIfNotExists = true;  // This will also create a user if it does not existing in the system.\r\nvar session = await facebookCredentials.AuthenticateAsync();\r\n\r\n// Alternatively, you could have used the following as well.\r\nawait App.LoginAsync(facebookCredentials);\r\n\r\n```\r\n\r\n#### Login with Twitter\r\n\r\nYou can ask your users to log in via Twitter. This'll require you to implement twitter login and provide the SDK with consumerkey, consumersecret, oauthtoken and oauthtokensecret\r\n```csharp\r\n\r\n//For login with twitter, pass twitter credentials to SDK\r\nvar twitterCredentials = new OAuth1Credentials(\r\n    consumerKey, \r\n    consumerSecret, \r\n    accessToken, \r\n    accessSecret, \r\n    \"twitter\");\r\ntwitterCredentials.CreateUserIfNotExists = true;\r\nvar session = await twitterCredentials.AuthenticateAsync();\r\n```\r\n\r\n#### Current User\r\n\r\nWhenever you authenticate a user using the `App.LoginAsync()` method, the user is stored in the platform specific local environment and can be retrieved using `App.Current.GetCurrentUser()`.\r\n\r\n```csharp\r\nvar userInfo = App.Current.GetCurrentUser();\r\n// If user is not logged in, userInfo would be null.\r\nif( userInfo != null )\r\n{\r\n    var userToken = userInfo.UserToken;\r\n    var loggedInUser = userInfo.User;\r\n}\r\n```\r\nYou can clear the current logged in user by calling `App.LogoutAsync()` method.\r\n```csharp\r\nawait App.LogoutAsync();\r\n```\r\n\r\n### Password Management\r\n\r\n#### Reset Password\r\n\r\nUsers often forget their passwords for your app. So you are provided with an API to reset their passwords. This api emails a single use url for resetting the password to the user's email address. \r\n\r\n```csharp\r\nawait APUsers.InitiateResetPasswordAsync(\r\n    username,           // username of the user\r\n    emailSubject        // subject of the password reset email (optional)\r\n    );      \r\n```\r\n\r\n----------\r\n\r\n## Emails\r\n\r\n### Configuring\r\n\r\nSending emails from the sdk is quite easy. There are primarily two types of emails that can be sent\r\n\r\n* Raw Emails\r\n* Templated Emails\r\n\r\nBefore you get to sending emails, you need to configure smtp settings. You can either configure it from the portal or in the api call with your mail provider's settings. To send emails via the SDK use the Email class. Alternatively, you can use the NewEmail fluent interface for sending emails as well, as shown below.\r\n\r\n### Sending Raw Emails\r\n\r\nA raw email is one where you can specify the entire body of the email. An email has the structure\r\n```csharp\r\nvar to = new [] {\"email1\", \"email2\"..}\r\nvar cc = new [] {\"email1\", \"email2\"..}\r\nvar bcc = new [] {\"email1\", \"email2\"..}\r\n\r\nawait NewEmail\r\n    .Create(\"This is a raw email test from the .NET SDK.\")\r\n    .To(to, cc, bcc)\r\n    .From(\"from@email.com\", \"replyto@email.com)\r\n    .WithBody(\"This is a raw body email.\")\r\n    .SendAsync();\r\n```\r\n\r\n### Sending Templated Emails\r\n\r\nYou can also save email templates in Appacitive and use these templates for sending mails. The template can contain placeholders that can be substituted before sending the mail. \r\n\r\nFor example, if you want to send an email to every new registration, it is useful to have an email template with placeholders for username and confirmation link.\r\n\r\nConsider we have created an email template called `welcome_email` with the following content.\r\n\r\n```csharp\r\n\"Welcome [#username] ! Thank you for downloading [#appname].\"\r\n```\r\nHere, [#username] and [#appname] denote the placeholders that we would want to substitute while sending an email. To send an email using this tempate, you would use something like this.\r\n\r\n```csharp\r\nvar to = new [] {\"email1\", \"email2\"..}\r\nvar cc = new [] {\"email1\", \"email2\"..}\r\nvar bcc = new [] {\"email1\", \"email2\"..}\r\n\r\n// Sending out a templated email\r\nawait NewEmail\r\n    .Create(\"Thank you for downloading our app\")\r\n    .To(to, cc, bcc)\r\n    .From(\"from@email.com\", \"replyto@email.com\")\r\n    .WithTemplateBody( \"welcome_email\", \r\n        new Dictionary<string, string> \r\n        {\r\n            {\"username\", \"john.doe\"},\r\n            {\"appname\", \"appacitive\"}\r\n        })\r\n    .SendAsync();\r\n```\r\n`Note`: Emails are not transactional. This implies that a successful send operation would mean that your email provider was able to dispatch the email. It DOES NOT mean that the intended recipient(s) actually received that email.\r\n\r\n----------\r\n\r\n## Push Notifications\r\n\r\nUsing Appacitive platform you can send push notification to iOS devices, Android base devices and Windows phone.\r\n \r\nYou will need to provide some basic one time configurations like certificates, using which we will setup push notification channels for different platforms for you. Also we provide a Push Console using which you can send push notification to the users.\r\n\r\nIn the .NET SDK, the static object `PushNotification` provides methods to send push notification.\r\n\r\nAppacitive provides five ways to select the recipients\r\n\r\n* Broadcast\r\n* Platform specific Devices\r\n* Specific List of Devices\r\n* To List of Channels\r\n* Query\r\n\r\nFirst we'll see how to send a push notification and then we will discuss the above methods with their options one by one.\r\n\r\n### Broadcast\r\n\r\nIf you want to send a push notification to all active devices, you can use the following options\r\n\r\n```csharp\r\nawait PushNotification\r\n\t\t// Send broadcast\r\n\t\t.Broadcast(\"Push from .NET SDK\")\r\n\t\t// Increment existing badge by 1\r\n\t\t.WithBadge(\"+1\")\r\n\t\t// Custom data field1 and field2\r\n\t\t.WithData(new { field1 = \"value1\", field2 = \"value2\" })\r\n\t\t// Expiry in seconds\r\n\t\t.WithExpiry(1000)\r\n\t\t// Device platform specific options\r\n\t\t.WithPlatformOptions(\r\n\t\t\tnew IOsOptions\r\n\t\t\t{\r\n\t\t\t\tSoundFile = soundFile\r\n\t\t\t})\r\n\t\t.WithPlatformOptions(\r\n\t\t\tnew AndroidOptions\r\n\t\t\t{\r\n\t\t\t\tNotificationTitle = title\r\n\t\t\t})\r\n\t\t.WithPlatformOptions(\r\n\t\t\tnew WindowsPhoneOptions\r\n\t\t\t{\r\n\t\t\t\tNotification = new ToastNotification\r\n\t\t\t\t{\r\n\t\t\t\t\tText1 = wp_text1,\r\n\t\t\t\t\tText2 = wp_text2,\r\n\t\t\t\t\tPath = wp_path\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t.SendAsync();\r\n```\r\n\r\n### Platform specific Devices\r\n\r\nIf you want to send push notifications to specific platforms, you can use this option. To do so you will need to provide the devicetype in the query.\r\n\r\n```csharp\r\nawait PushNotification\r\n    // Send to specific device types\r\n    .ToQueryResult( Query.Property(\"devicetype\").IsEqualTo(\"ios\"))\r\n    // Increment existing badge by 1\r\n    .WithBadge(\"+1\")\r\n    // Custom data field1 and field2\r\n    .WithData(new { field1 = \"value1\", field2 = \"value2\" })\r\n    // Expiry in seconds\r\n    .WithExpiry(1000)\r\n    .SendAsync();\r\n```\r\n\r\n### Specific List of Devices\r\n\r\nIf you want to send push notifications to specific devices, you can use this option. To do so you will need to provide the device ids.\r\n\r\n```csharp\r\nvar deviceIDs = new [] {\"id1\", \"id2\",..}; \r\nawait PushNotification\r\n    // Send specific device ids\r\n    .ToDeviceIds(\"Push from .NET SDK\", deviceIDs);\r\n    // Increment existing badge by 1\r\n    .WithBadge(\"+1\")\r\n    // Custom data field1 and field2\r\n    .WithData(new { field1 = \"value1\", field2 = \"value2\" })\r\n    // Expiry in seconds\r\n    .WithExpiry(1000)\r\n    .SendAsync();\r\n```\r\n\r\n### To List of Channels\r\n\r\nDevice object has a Channel property, using which you can club multiple devices. This is helpful if you want to send push notification using channel.\r\n\r\n```csharp\r\nvar channels = new [] {\"channel1\", \"channel2\",..}; \r\nawait PushNotification\r\n    // Send specific channels\r\n    .ToChannels(\"Push from .NET SDK\", channels);\r\n    // Increment existing badge by 1\r\n    .WithBadge(\"+1\")\r\n    // Custom data field1 and field2\r\n    .WithData(new { field1 = \"value1\", field2 = \"value2\" })\r\n    // Expiry in seconds\r\n    .WithExpiry(1000)\r\n    .SendAsync();\r\n```\r\n### Query\r\n\r\nYou can send push notifications to devices using a Query. All the devices which comes out as result of the query will receive the push notification.\r\n\r\n```csharp\r\nIQuery query =  Query.Property(..;       // create query\r\nawait PushNotification\r\n    // Send to results from a query\r\n    .ToQueryResult(query)\r\n    // Increment existing badge by 1\r\n    .WithBadge(\"+1\")\r\n    // Custom data field1 and field2\r\n    .WithData(new { field1 = \"value1\", field2 = \"value2\" })\r\n    // Expiry in seconds\r\n    .WithExpiry(1000)\r\n    .SendAsync();\r\n```\r\n### Platform specific options\r\nThe `PushNotification` fluent interface provides a `WithPlatformOptions` method to pass different phone platform specific options as shown in the example below.\r\n```csharp\r\nawait PushNotification\r\n        // Send specific device ids\r\n        .Broadcast(\"Hello from the .NET SDK\")\r\n        // Device platform specific options\r\n        .WithPlatformOptions(\r\n            new IOsOptions\r\n            {\r\n                SoundFile = soundFile\r\n            })\r\n        .WithPlatformOptions(\r\n            new AndroidOptions\r\n            {\r\n                NotificationTitle = title\r\n            })\r\n        .WithPlatformOptions(\r\n            new WindowsPhoneOptions\r\n            {\r\n                Notification = new ToastNotification\r\n                {\r\n                    Text1 = wp_text1,\r\n                    Text2 = wp_text2,\r\n                    Path = wp_path\r\n                }\r\n            })\r\n        .SendAsync();\r\n```\r\n\r\n### Different options for windows phone.\r\nFor windows phone 3 types of notifications are supported.\r\n1. Toast notifications.\r\n2. Tile notifications (flip, cyclic and iconic)\r\n3. Raw notifications (string based raw data)\r\n\r\nThe windows phone platform options allows you to choose the specific kind of notification to be \r\nsend to each windows phone device type (WP7, WP75 and WP8).\r\nThe sample below shows how this can be done.\r\n\r\n``` C#\r\n// Toast\r\nawait PushNotification\r\n\t\t.Broadcast(\"message\")\r\n\t\t.WithPlatformOptions(\r\n\t\t\tnew WindowsPhoneOptions\r\n\t\t\t{\r\n\t\t\t\tNotification = new ToastNotification\r\n\t\t\t\t{\r\n\t\t\t\t\tText1 = wp_text1,\r\n\t\t\t\t\tText2 = wp_text2,\r\n\t\t\t\t\tPath = wp_path\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t.SendAsync();\r\n\r\n// Raw notification\r\nawait PushNotification\r\n\t\t.Broadcast(\"message\")\r\n\t\t.WithPlatformOptions(\r\n            new WindowsPhoneOptions\r\n                {\r\n                    Notification = new RawNotification() { RawData = \"string data..\" }\r\n                })\r\n\t\t.SendAsync();\r\n\r\n// Tile notification (Flip tile for all)\r\nawait PushNotification\r\n\t\t.Broadcast(\"message\")\r\n\t\t.WithPlatformOptions(\r\n                    new WindowsPhoneOptions\r\n                    {\r\n                        Notification = TileNotification.CreateNewFlipTile( \r\n                            new FlipTile() { FrontTitle = title, .. } )\r\n                    })\r\n\t\t.SendAsync();\r\n\r\n\r\n// Tile notification (cyclic tile for wp8, flip tile for others)\r\nawait PushNotification\r\n\t\t.Broadcast(\"message\")\r\n\t\t.WithPlatformOptions(\r\n                    new WindowsPhoneOptions\r\n                    {\r\n                        Notification = TileNotification.CreateNewCyclicTile( \r\n                            new CyclicTile(), new FlipTile() )\r\n                    })\r\n\t\t.SendAsync();\r\n\r\n// Tile notification (iconic tile for wp8, flip tile for others)\r\nawait PushNotification\r\n\t\t.Broadcast(\"message\")\r\n\t\t.WithPlatformOptions(\r\n                    new WindowsPhoneOptions\r\n                    {\r\n                        Notification = TileNotification.CreateNewIconicTile( \r\n                            new IconicTile(), new FlipTile() )\r\n                    })\r\n\t\t.SendAsync();\r\n\r\n```\r\n----------------\r\n\r\n## Files\r\n\r\nAppacitive supports file storage and provides api's for you to easily upload and download file. In the background we use amazon's S3 services for persistance. \r\nAll file upload and download operations in the SDK are handled by the `FileUpload` and `FileDownload` classes respectively. \r\n\r\n`NOTE`: All file operations need a file name. This name can be supplied on upload by the user or can be auto generated to be unique by the api. Some important things to note about the file name are -\r\n\r\n* It is not mandatory.\r\n* It does not have to be the same is the name of the file being uploaded.\r\n* Incase it is not supplied, it will be auto generated and returned in the response.\r\n* It is the only handle to download the file, so do not lose it.\r\n\r\n### Uploading a new file\r\n\r\nTo upload a new file, create a new instance of the `FileUpload` class with the mime type and optional filename. If you do not supply a file name, an auto generated name will be returned in the response.\r\n\r\n``` C#\r\n// To upload an png image with filename testimage.png\r\nvar mimeType = \"image/png\";\r\nvar filePath = ...\t\t\t\t// Path to the file\r\nvar userSpecifiedFileName = \"testimage.png\";\r\n// filenameOnServer will be testimage.png.\r\nvar fileNameOnServer = await new FileUpload(mimeType, userSpecifiedFileName).UploadFileAsync(filePath);\r\n\r\n\r\n\r\n// To upload an png image without specifying a filename\r\nvar mimeType = \"image/png\";\r\nvar filePath = ...\t\t\t\t// Path to the file\r\n// filenameOnServer will be auto generated\r\nvar fileNameOnServer = await new FileUpload(mimeType).UploadFileAsync(filePath);\r\n\r\n\r\n// To upload an png image as a byte array\r\nvar mimeType = \"image/png\";\r\nbyte[] data = ...\t\t\t\t\t\t\t\t// PNG file data\r\nvar filePath = ...\t\t\t\t\t\t\t\t// Path to the file\r\n// filenameOnServer will be auto generated\r\nvar fileNameOnServer = await new FileUpload(mimeType).UploadAsync(data);\r\n\r\n```\r\n\r\n\r\n### Generate url to upload file to\r\nIncase you want to handle the file upload yourself via some custom control or code, you can generate an upload url which will be available for a limited time period to which you can upload the file. The life time of the upload url can be specified in the api call.\r\n\r\nThe following code snippet shows how this can be done.\r\n\r\n``` C#\r\n// Say you want the upload url to upload a PNG image.\r\nvar mimeType = \"image/png\";\r\nint expiryInMinutes = 10;\t\t\t\t// Upload url will remain active for next 10 mins\r\nvar fileUrl = await new FileUpload(mimeType).GetUploadUrlAsync(expiryInMinutes);\r\n\r\nvar nameOnServer = fileUrl.FileName;\t// This will be the filename on the server (auto generated in this case)\r\nvar urlToUpload = fileUrl.Url;\t\t\t// This will be the url to upload to.\r\n```\r\n\r\n\r\n### Download an existing file\r\nTo download an existing file from the platform, you need the filename of the file returned from the Upload api. With this filename you can download the file using the `FileDownload` class.\r\n\r\n``` C#\r\n// To download a file and save to disk\r\nvar filename = ...;\t\t\t// File name of the file to download.\r\nvar saveAsFilePath = ...;\t// Path to save the downloaded file.\r\n// The file will be downloaded and saved to the saveAs path specified.\r\nawait new FileDownload(filename).DownloadFileAsync(saveAsFilePath);\r\n\r\n\r\n// To download file contents as byte array\r\nvar filename = ...;\t\t\t// File name of the file to download.\r\nvar saveAsFilePath = ...;\t// Path to save the downloaded file.\r\n// The file will be downloaded and saved to the saveAs path specified.\r\nbyte[] contents = await new FileDownload(filename).DownloadAsync();\r\n```\r\n\r\n\r\n### Generate a public url for an existing file.\r\nAll files uploaded to the Appacitive platform are private by default and cannot be accessed via a http GET to a url alone. You can generate a permanent public url for your file or a limited time public url for your file.\r\nTo generate a permanently public url for a file, use the `FileDownload.GetPublicUrlAsync()` api. To generate a limited time public url for your file, use the `FileDownload.GetDownloadUrlAsync` method.\r\n\r\n`NOTE`:  One important thing to note is that generating a permanently public url for a file marks the file as public. Such files cannot be used to generate limited time public urls any more.\r\n\r\n``` C#\r\n\r\n// To generate a limited time (10 mins) public url for a file\r\nvar filename = ...;\t\t\t\t\t\t\t// File name of the file to download.\r\nvar expiryInMinutes = 10;\t                // Public url that will be active for next 10 mins\r\n\r\n// Get limited time public url\r\nstring limitedTimePublicUrl = await new FileDownload(filename).GetDownloadUrlAsync(expiryInMinutes);\r\n\r\n// Get permanently public url\r\nstring permanentPublicUrl = await new FileDownload(filename).GetPublicUrlAsync();\r\n\r\n```\r\n\r\n----------\r\n\r\n## WCF gotchas\r\nWhen using the SDK on the server side inside a web application or web service, we need to make sure that the ambient user context and sdk state is available on a per request basis instead of being statically stored for the entire application. The SDK uses the WCF OperationContext to store and manage this information on a per request basis.\r\nHowever given the fact that the SDK methods are async, special provisions need to be made to ensure that the OperationContext is available across threads. To do this, service implementations using the SDK must apply the `AllowAsyncService` service\r\nbehavior to their service implementations. This can be done in two ways.\r\n\r\n#### 1. Via attribution\r\n``` C#\r\n/*\r\nAdd the AllowAsyncService to ensure that OperationContext \r\nis propogated across async calls.\r\n*/\r\n[AllowAsyncService]\r\npublic class MyWebService : IMyWebService\r\n{\r\n\t...\r\n}\r\n```\r\n\r\n#### 2. Via web.config\r\n\r\n``` xml\r\n<!-- Define a behavior extension inside the wcf service model configuration -->\r\n<behaviorExtensions>\r\n    <!-- incase of using .NET 4.0 version of sdk -->\r\n    <add name=\"allowAsyncCalls\" type=\"Appacitive.Sdk.Wcf.AllowAsyncServiceBehaviorExtension, Appacitive.Sdk.Net40\" />\r\n    <!-- incase of using .NET 4.5 version of sdk -->\r\n    <add name=\"allowAsyncCalls\" type=\"Appacitive.Sdk.Wcf.AllowAsyncServiceBehaviorExtension, Appacitive.Sdk.Net45\" />\r\n</behaviorExtensions>\r\n\r\n<!-- Use the extension inside your service / endpoint / operation behavior configuration. -->\r\n```\r\n\r\n  [1]: https://www.appacitive.com\r\n  [2]: http://www.apache.org/licenses/LICENSE-2.0.html\r\n  [3]: http://en.wikipedia.org/wiki/Multiversion_concurrency_control\r\n  [4]: http://lucene.apache.org/core/3_0_3/queryparsersyntax.html","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}